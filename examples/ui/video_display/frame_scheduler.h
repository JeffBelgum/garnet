
#pragma once

#include <stdint.h>
#include <deque>
#include <mutex>


namespace video_display {

// FrameScheduler determines when your next frame should be presented.
// The timing of a frame depends on a number of factors:
// When the frame is generated by the source
// When previous frames were consumed by the sink
// At what the intervals the sink conusumes frames
// This scheduler handles two main events:
// When a new frame is available, (EnqueBuffer) and 
// when the consumer signals that the frame is presented. (Update)
// This scheduler tries to ensure that frames will be presented as quickly
// as possible, with as few dropped frames as possible. It works with the
// assumption that the consumer will drop any frames that are within one
// presentation interval of a previous frame, or that have a presentation time
// that is in the past.
// Since any enqued frames cannot change their presentation time, the scheduler
// keeps track of the next time a future frame should be presented, based on
// calls to the Update function.
// For Example:
// if the presentation interval were 3, and we have 2 frames: 
// Frame_1 enqued for presentation at t = 10
// Frame_2 enqued for presentation at t = 13,
// A call to enque Frame_3 would give it the presentation time of 16.
// If we then got an update that Frame_1 was actually presented at t = 12,
// We cannot change frame 2 or 3's time, but we can ensure that
// A call to enque Frame_4 would give it the presentation time of 21. 
// (3 intervals from frame_1 to frame_4 * presentation_interval of 3 + 12 = 21
//
// This class also keeps track of what frames are already enqued, and returns
// failure if a frame is attempted to be enqued twice.
class FrameScheduler {
 public:
 
  // Add a frame to the queue, and return the time in ns, relative to 
  // CLOCK_MONOTONIC when it should be presented
  uint64_t EnqueBuffer(uint32_t buffer_id);

  // Update the scheduler that a frame is presented.
  // @param presentation_time the time in ns, relative to CLOCK_MONOTONIC
  // when the frame with buffer id == buffer_id was presented
  // @param presentation_interval the period in ns between frame presentations
  int32_t Update(uint64_t presentation_time, uint64_t presentation_interval,
                  uint32_t buffer_id);

  // Remove a buffer from the queue 
  int32_t ReleaseBuffer(uint32_t buffer_id);
  bool IsEnqueued(uint32_t buffer_id);

 private:
  int32_t FindBuffer(uint32_t buffer_id);
  int32_t GetFirstUnpresented();

  struct EnquedBuffer {
        uint32_t id;
        uint64_t requested_pres_time;
        bool presented = false;
    };

  uint64_t presentation_interval_ns_ = 33000000;
  uint64_t last_presentation_time_ns_ = 0;
  std::deque<EnquedBuffer> buffers_;
  std::mutex time_lock_;

};

}  // namespace video_display

