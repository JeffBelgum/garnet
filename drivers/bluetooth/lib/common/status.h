// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#pragma once

#include <cstdint>
#include <string>

#include "lib/fxl/logging.h"
#include "lib/fxl/strings/string_printf.h"

namespace btlib {
namespace common {

// Status types used for internal errors generated by the host
enum class HostError : uint8_t {
  kNoError = 0u,

  // Not found.
  kNotFound,

  // Not ready.
  kNotReady,

  // The time limit for the operation has expired.
  kTimedOut,

  // The operation was initiated with invalid parameters.
  kInvalidParameters,

  // The operation was canceled.
  kCanceled,

  // Operation is already in progress.
  kInProgress,

  // Operation is not supported by the host.
  kNotSupported,

  // Received an invalid packet from the controller.
  kPacketMalformed,

  // Link was disconnected during operation.
  kLinkDisconnected,

  // Ran out of resources.
  kOutOfMemory,

  // Error code for protocol errors. The actual error code is specified by a
  // protocol error code type.
  kProtocolError,

  // Generic error code. Use this only if another error code does not accurately
  // capture the failure condition.
  kFailed,
};

// Returns a string representation of HostError.
std::string HostErrorToString(HostError error);

// Required trait for ProtocolErrorCode types.
template <typename ProtocolErrorCode>
struct ProtocolErrorTraits {
  // Returns a string representation of the given ProtocolErrorCode value.
  static std::string ToString(ProtocolErrorCode);
};

template <typename ProtocolErrorCode>
class Status {
  using ProtoTraits = ProtocolErrorTraits<ProtocolErrorCode>;

 public:
  // The result will carry a protocol error code.
  constexpr explicit Status(ProtocolErrorCode proto_code)
      : error_(HostError::kProtocolError), protocol_error_(proto_code) {}

  // The result will carry a host error. Constructs a success result by default.
  constexpr explicit Status(HostError ecode = HostError::kNoError)
      : error_(ecode) {
    FXL_DCHECK(ecode != HostError::kProtocolError)
        << "HostError::kProtocolError not allowed in HostError constructor";
  }

  // Returns true if this is a success result.
  bool is_success() const { return error_ == HostError::kNoError; }

  // Returns the host error code.
  HostError error() const { return error_; }

  // Returns true if this result is a protocol error.
  bool is_protocol_error() const { return error_ == HostError::kProtocolError; }

  // Returns the protocol error code. This value is undefined if error() is
  // not equal to HostError::kProtocolError.
  ProtocolErrorCode protocol_error() const { return protocol_error_; }

  // Returns true if this is a success result.
  operator bool() const { return is_success(); }

  // Returns a string representation.
  inline std::string ToString() const {
    return fxl::StringPrintf(
        "[status: %s]",
        (is_protocol_error() ? ProtoTraits::ToString(protocol_error())
                             : HostErrorToString(error()))
            .c_str());
  }

  bool LogIfError(fxl::LogSeverity severity, const char* file, int line,
                  std::string msg) {
    if (!is_success()) {
      FXL_LAZY_STREAM(fxl::LogMessage(severity, file, line, nullptr).stream(),
                      fxl::ShouldCreateLogMessage(severity))
          << msg << ": " << ToString();
    }
    return !is_success();
  }

 private:
  HostError error_;
  ProtocolErrorCode protocol_error_;
};

}  // namespace common
}  // namespace btlib

// Macros to check and log any non-Success status of an event.
// Use these like:
// if (BT_TEST_ERR(status, WARNING, "gap: failed set event mask")) {
//   // cleanup or callback with error, or don't, I'm a coment, not a cop.
//   return;
// }
// or
// BT_TEST_WARN(status, "gap (BR/EDR): failed set page scan");
//
// It will log with the string prepended to the stringified status if it
// is not success.
//
// Evaluates to true if the event status is not success.

#define BT_TEST_LOG(status, severity, msg) \
  (status.LogIfError(fxl::LOG_##severity, __FILE__, __LINE__, msg))
#define BT_TEST_ERR(status, msg) BT_TEST_LOG(status, ERROR, msg)
#define BT_TEST_WARN(status, msg) BT_TEST_LOG(status, WARNING, msg)
#define BT_TEST_VLOG(status, level, msg) \
  (status.LogIfError(-level, __FILE__, __LINE__, msg))
