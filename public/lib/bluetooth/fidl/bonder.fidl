library bluetooth_bonder;

struct Key {
  bool authenticated;

  // 128 bit key
  array<uint8>:16 value;
};

// Represents a LE Long-Term Key. The |ediv| and |rand| fields are zero if
// distributed using LE Secure Connections pairing.
struct LTK {
  Key key;
  uint8 key_size;
  uint16 ediv;
  uint64 rand;
};

// The preferred LE connection parameters of the peer.
struct LEConnectionParameters {
  uint16 connection_interval;
  uint16 connection_latency;
  uint16 supervision_timeout;
};

struct LEData {
  // The identity address of the peer. If |resolvable| is true, then this is the
  // resolved private address (and the |irk| is present).
  string address;

  bool resolvable;

  // True if the peer is the master of the connection.
  bool master;

  // The peerâ€™s preferred connection parameters, if known.
  LEConnectionParameters? connection_parameters;

  // Known GATT service UUIDs.
  vector<string> services;

  // The LE long-term key. Present if the link was encrypted.
  LTK? ltk;

  // Identity Resolving Key used to generate and resolve random addresses.
  Key? irk;

  // Connection Signature Resolving Key used for data signing without encryption.
  Key? csrk;
};

struct BondingData {
  string name;
  LEData? le;
};

interface Bonder {
  // Initializes bonded devices for the local host identified by |local_id|. This is the same
  // as the ID provided in OnDeviceBonded().
  1: AddBondedDevices(string local_id, vector<BondingData> bonds) -> (bluetooth.Status @status);

  //  2: AddOutOfBandData(string local_id, string peer_address, OOBData? bredr_data, LEOOB? le_data) -> (bluetooth.Status @status);

  // Called when the pairing procedure with a new peer has completed or when new data for an
  // existing bond is available.
  103: -> OnNewBondingData(string local_id, BondingData data);
};
